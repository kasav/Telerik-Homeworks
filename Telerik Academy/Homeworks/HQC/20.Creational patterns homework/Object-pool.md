# Object pool #
----------

## Цели ##
- Да се осигури генерирането на един или няколко "скъпи" и трудоемки за създаване обекти,поддържането им в състояние за непосредствена употреба при нужда и повторното им преизползване чрез връщането им в начално състояние. 


## Приложимост ##

Пестене на ресурси и съответно повишаване на ефективността при изпълнение на бавни операции като
 
- отваряне на нови връзки с бази данни
- създаване на нови файлове
- изтегляне на ресурси от интернет и др.




## Структура ##
![](http://www.blackwasp.co.uk/images/ObjectPool.png)



**Client** - Инстанциите на класове в тази роля използват PoolObject обектите

**PooledObject** - Инстанциите, които са скъпи или бавни за създаване или са ограничени, поради което се съхраняват

**Pool** - клас, който контролира достъпа до обектите и съдържа лист със свободните обекти, обектите, които вече са заявени и обектите, които са заети. Също така се грижи за връщането на обектите в началното състояние след като сса освободени и преди да се използват отново

## Имплементация


	public class PooledObject
	{
    DateTime _createdAt = DateTime.Now;
 
    public DateTime CreatedAt
    {
        get { return _createdAt; }
    }
 
    public string TempData { get; set; }
	}
 
	public static class Pool
	{
    private static List<PooledObject> _available = new List<PooledObject>();
    private static List<PooledObject> _inUse = new List<PooledObject>();
 
    public static PooledObject GetObject()
    {
        lock(_available)
        {
            if (_available.Count != 0)
            {
                PooledObject po = _available[0];
                _inUse.Add(po);
                _available.RemoveAt(0);
                return po;
            }
            else
            {
                PooledObject po = new PooledObject();
                _inUse.Add(po);
                return po;
            }
        }
    }
 
    public static void ReleaseObject(PooledObject po)
    {
        CleanUp(po);
 
        lock (_available)
        {
            _available.Add(po);
            _inUse.Remove(po);
        }
    }
 
    private static void CleanUp(PooledObject po)
    {
        po.TempData = null;
    }
	}

## Особености ##
- Обикновено reusable pool-a е имплементиран като Сингълтън с цел осигуряване на единствена инстанция.
- Броят на ресурсите в pool-a остава ограничен и при твърде голямо натоварване може да се наложи изчакване за освобождаване на обект, свързано със съответното забавяне. От друга страна големината на обектите е фиксирана и неизползваните обекти остават в паметта
- Системата зависи от освобождаването на ресурси от клиента, което не винаги се случва. Често се налага прилагането на механизъм, който да следи кога за последно е използван даден обект и при изтичане на определено време да го връща автоматично в pool-a


## Проблеми ##
- Трябва да се осигури връщането на обектите в началното им състояние преди да бъдат повторно използвани. Това остава отговорност на pool-a, а не на клиента, и pool-a носи отговорността обектите да не са в невалиден стейт
- Невърнати в начално състояние обекти могат причинят както проблем със сигурността на данните, останали в самите тях тях, така и проблем, свързан с неоторизиран достъп до други ресурси (неизтрити данни за ауторизация).





